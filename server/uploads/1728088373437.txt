Ты ведущий программист с 10-ти летним стажем по Javascript. Я создал SPA-приложение на Nodejs/express, и React c использованием технологии websocket при помощи библиотеки socket.io. У меня сообщения нормально выводятся. Но мне нужно сделать так, чтобы один пользователь мог ответить на сообщения другого пользователя. На каждую сообщение можно написать сколько угодно сообщений(каскадное отображение). В следующем сообщении я тебе скину мой код, и ты постарайся его исправить чтобы все работало как я просил и прокомментируй твой код, там где ты будешь вносить изменения

===================================

вот код бэкенда index.js - const express = require("express"); const cors = require("cors"); const app = express(); const http = require("http").Server(app); const socketIO = require("socket.io")(http, {     cors: {         origin: "http://localhost:5173",     }, });  const PORT = 5000; const HOST = "localhost";  app.get("api", (req, res) => {     res.json({         message: "Hello",     }); });  let users = []; // Храним информацию о пользователях  socketIO.on("connect", (socket) => {     console.log(${socket.id} user connected);      socket.on("newUser", (data) => {         // Проверяем, есть ли пользователь с таким же socketID         const existingUser = users.find((user) => user.socketID === socket.id);         if (!existingUser) {             // Если пользователь с таким socketID не найден, добавляем его             users.push({ user: data.user, socketID: socket.id });             socketIO.emit("responseNewUser", users);         }     });      // socket.on("message", (data) => {     //     socketIO.emit("response", data);     // });      // Обработчик события отправки сообщения     socket.on("message", (data) => {         const message = {             ...data, // включаем существующие поля (текст, имя пользователя и т.д.)             parentId: data.parentId || null, // добавляем поле parentId для хранения ID родительского сообщения         };         socketIO.emit("response", message); // отправляем сообщение всем пользователям     });      // socket.on("typing", (data) => socket.broadcast.emit("responseTyping", data));      // Новое событие для удаления пользователя при логауте     socket.on("logout", ({ user, socketID }) => {         // console.log(Logout received: ${user} with socketID ${socketID});         users = users.filter((u) => u.socketID !== socketID); // Удаляем пользователя по socketID         socketIO.emit("responseNewUser", users); // Обновляем список пользователей         console.log(${user} (${socketID}) has left the chat); // Логируем факт выхода     });      // Обновлённая обработка отключения пользователя     socket.on("disconnect", () => {         users = users.filter((u) => u.socketID !== socket.id); // Удаляем пользователя по его socketID         socketIO.emit("responseNewUser", users); // Обновляем список пользователей         console.log(${socket.id} disconnected); // Логируем разрыв соединения     }); });  const start = async () => {     try {         http.listen(PORT, (err) => {             err                 ? console.log(err)                 : console.log(Server running on http://${HOST}:${PORT});         });     } catch (err) {         console.error("Error starting the server:", err);     } };  start();   Далее код фронта, файл body - import React, { useEffect } from "react"; import { useNavigate } from "react-router-dom"; import styles from "./styles.module.css";  const Body = ({ messages, status, socket }) => {     const navigate = useNavigate();      const handleLeave = () => {         const user = localStorage.getItem("user");         // Проверка, если socket не передан         if (!socket) {             console.error("Socket not found!");             return;         }         const socketID = socket.id;          // Эмитим событие logout, чтобы сервер удалил пользователя из списка         socket.emit("logout", { user, socketID });          localStorage.removeItem("user"); // Удаляем данные пользователя из localStorage         navigate("/"); // Перенаправляем на главную страницу     };      // Эффект, который срабатывает при обновлении списка сообщений     useEffect(() => {         // Скроллим страницу вниз каждый раз, когда добавляется новое сообщение         window.scrollTo(0, document.body.scrollHeight);     }, [messages]); // Зависимость от изменений в массиве сообщений      return (         <>             <header className={styles.header}>                 <button className={styles.btn} onClick={handleLeave}>                     Покинуть чат                 </button>             </header>              <div className={styles.container}>                 {messages.map((element) =>                     element.name === localStorage.getItem("user") ? (                         <div className={styles.chats} key={element.id}>                             <p className={styles.senderName}>Вы</p>                             <div className={styles.messageSender}>                                 <p>{element.text}</p>                             </div>                         </div>                     ) : (                         <div className={styles.chats} key={element.id}>                             <p>{element.name}</p>                             <div className={styles.messageRecipient}>                                 <p>{element.text}</p>                             </div>                         </div>                     )                 )}                  <div className={styles.status}>                     <p>{status}</p>                 </div>             </div>         </>     ); };  export default Body;   Далее файл sidebar - import React, { useEffect, useState } from "react"; import styles from "./styles.module.css";  const SideBar = ({ socket }) => {     const [users, setUsers] = useState([]);      useEffect(() => {         // Обновляем список пользователей при получении данных с сервера         socket.on("responseNewUser", (data) => setUsers(data));     }, [socket]);      const filteredList = users.filter(         (value, index, self) =>             index ===             self.findIndex(                 (t) => t.user === value.user && t.socketID === value.socketID             )     );     return (         <div className={styles.sidebar}>             <h4 className={styles.header}> Users</h4>             <ul className={styles.users}>                 {filteredList.map((element) => (                     <li key={element.socketID}>{element.user}</li>                 ))}             </ul>         </div>     ); };  export default SideBar; Далее файл message-block - import React, { useState } from "react"; import styles from "./styles.module.css";  const MessageBlock = ({ socket }) => {     const [message, setMessage] = useState("");      const isTyping = () =>         socket.emit("typing", ${localStorage.getItem("user")} is typing);      const handleSend = (e) => {         e.preventDefault();         if (message.trim() && localStorage.getItem("user")) {             socket.emit("message", {                 text: message,                 name: localStorage.getItem("user"),                 id: ${socket.id}-${Math.random()},                 socketID: socket.id,             });         }         setMessage("");     };     return (         <div className={styles.messageBlock}>             <form className={styles.form} onSubmit={handleSend}>                 <input                     type='text'                     className={styles.userMessage}                     value={message}                     onChange={(e) => setMessage(e.target.value)}                     onKeyDown={isTyping}                 />                 <button className={styles.btn}>Сказать</button>             </form>         </div>     ); };  export default MessageBlock;   И файл index.js - import React, { useEffect, useState } from "react";
import SideBar from "./components/sidebar/sidebar";
import Body from "./components/body/body";
import MessageBlock from "./components/message-block/message-block";
import styles from "./styles.module.css";

const ChatPage = ({ socket }) => {
    const [messages, setMessages] = useState([]);
    const [status, setStatus] = useState("");

    // Обработка получения новых сообщений
    useEffect(() => {
        socket.on("response", (data) => setMessages([...messages, data]));
    }, [socket, messages]);

    useEffect(() => {
        socket.on("responseTyping", (data) => {
            setStatus(data);
            setTimeout(() => {
                setStatus("");
            }, 1000);
        });
    }, [socket]);

    return (
        <div className={styles.chat}>
            <SideBar socket={socket} />
            <main className={styles.main}>
                <Body messages={messages} status={status} socket={socket} />
                <MessageBlock socket={socket} />
            </main>
        </div>
    );
};

export default ChatPage;